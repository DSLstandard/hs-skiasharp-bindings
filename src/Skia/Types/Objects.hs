module Skia.Types.Objects where

import NeatInterpolation
import Skia.Bindings.Internal.AutoGenerated
import Skia.Types.Core
import Skia.Types.Internal.Utils.TH

-- ### Mono Skia's opaque structs

$( qGenerateSKObject
    "SKRefCnt"
    ''Sk_refcnt
    -- NOTE: In reality, @class SK_API SkRefCnt : public SkRefCntBase@, but we
    -- shall ignore it.
    [] -- class SK_API SkRefCnt : public SkRefCntBase {
    [trimming|
        Google Skia's internal reference counting base class.
    |]
 )

$( qGenerateSKObject
    "SKNVRefCnt"
    ''Sk_nvrefcnt
    [] -- class SkNVRefCnt {
    [trimming|
        This is a special variant SkRefCnt. @NV@ stands for (N)ot (V)irtual.
        
        This class exists in Google Skia to handle objects and C++ vtable shenanigans.
    |]
 )

$( qGenerateFakeSKObject
    "SKWeakRefCnt"
    [''SKRefCnt] -- class SK_API SkWeakRefCnt : public SkRefCnt {
    [trimming|
        SkWeakRefCnt is the base class for objects that may be shared by multiple
        objects. When an existing strong owner wants to share a reference, it calls
        ref(). When a strong owner wants to release its reference, it calls
        unref(). When the shared object's strong reference count goes to zero as
        the result of an unref() call, its (virtual) weak_dispose method is called.
        It is an error for the destructor to be called explicitly (or via the
        object going out of scope on the stack or calling delete) if
        getRefCnt() > 1.
    |]
 )

$( qGenerateSKObject
    "SKFlattenable"
    ''Sk_flattenable
    [''SKRefCnt] -- class SK_API SkFlattenable : public SkRefCnt {
    [trimming|
        'SKFlattenable' is the base class for objects that need to be flattened
        into a data stream for either transport or as part of the key to the
        font cache.

        Note from developer: you do not really need to understand what the description
        talking about. You never, or at least rarely, encounter 'SKFlattenable' when using this Haskell library.
    |]
 )

-- This is replaced by 'data SurfaceProps':
-- \$(qGenerateSKObject "SKSurfaceProps" ''Sk_surfaceprops)

$( qGenerateSKObject
    "SKCanvas"
    ''Sk_canvas
    [] -- class SK_API SkCanvas {
    [trimming|
        SkCanvas provides an interface for drawing, and how the drawing is clipped and transformed.
        SkCanvas contains a stack of SkMatrix and clip values.

        SkCanvas and SkPaint together provide the state to draw into SkSurface or SkDevice.
        Each SkCanvas draw call transforms the geometry of the object by the concatenation of all
        SkMatrix values in the stack. The transformed geometry is clipped by the intersection
        of all of clip values in the stack. The SkCanvas draw calls use SkPaint to supply drawing
        state such as color, SkTypeface, text size, stroke width, SkShader and so on.

        To draw to a pixel-based destination, create raster surface or GPU surface.
        Request SkCanvas from SkSurface to obtain the interface to draw.
        SkCanvas generated by raster surface draws to memory visible to the CPU.
        SkCanvas generated by GPU surface uses Vulkan or OpenGL to draw to the GPU.

        To draw to a document, obtain SkCanvas from SVG canvas, document PDF, or SkPictureRecorder.
        SkDocument based SkCanvas and other SkCanvas subclasses reference SkDevice describing the
        destination.

        SkCanvas can be constructed to draw to SkBitmap without first creating raster surface.
        This approach may be deprecated in the future.
    |]
 )

$( qGenerateSKObject
    "SKCanvasSaveLayerRec"
    ''Sk_canvas_savelayerrec
    [] -- struct SaveLayerRec {
    [trimming|
        This is an internal class of 'SKCanvas'.
        
        'SKCanvasSaveLayerRec' contains the state used to create a layer in 'SKCanvas'.
    |]
 )

$( qGenerateSKObject
    "SKNoDrawCanvas"
    ''Sk_nodraw_canvas
    [''SKCanvas] -- class SK_API SkNoDrawCanvas : public SkCanvasVirtualEnforcer<SkCanvas> {
    [trimming|
        SkNoDrawCanvas is a helper for SkCanvas subclasses which do not need to
        actually rasterize (e.g., analysis of the draw calls).

        It provides the following simplifications:

          * not backed by any device/pixels

          * conservative clipping (clipping calls only use rectangles)
    |]
 )

$( qGenerateSKObject
    "SKNWayCanvas"
    ''Sk_nway_canvas
    [''SKNoDrawCanvas] -- class SK_API SkNWayCanvas : public SkCanvasVirtualEnforcer<SkNoDrawCanvas> {
    [trimming|
        An 'SKCanvas' subclass that sends the input draw commands to multiple 'SKCanvas'es.
    |]
 )

$( qGenerateSKObject
    "SKOverdrawCanvas"
    ''Sk_overdraw_canvas
    [''SKNWayCanvas] -- class SK_API SkOverdrawCanvas : public SkCanvasVirtualEnforcer<SkNWayCanvas> {
    [trimming|
        Captures all drawing commands.  Rather than draw the actual content, this device
        increments the alpha channel of each pixel every time it would have been touched
        by a draw call.  This is useful for detecting overdraw.
    |]
 )

$( qGenerateSKObject
    "SKData"
    ''Sk_data
    [''SKNVRefCnt] -- class SK_API SkData final : public SkNVRefCnt<SkData> {
    [trimming|
        SkData holds an immutable data buffer. Not only is the data immutable,
        but the actual ptr that is returned (by 'withData') is guaranteed
        to always be the same for the life of this instance.
    |]
 )

$( qGenerateSKObject
    "SKDrawable"
    ''Sk_drawable
    [''SKFlattenable] -- class SK_API SkDrawable : public SkFlattenable {
    [trimming|
        Base-class for objects that draw into SkCanvas.

        The object has a generation ID, which is guaranteed to be unique across all drawables. To
        allow for clients of the drawable that may want to cache the results, the drawable must
        change its generation ID whenever its internal state changes such that it will draw differently.
    |]
 )

$( qGenerateSKObject
    "SKImage"
    ''Sk_image
    [''SKRefCnt] -- class SK_API SkImage : public SkRefCnt {
    [trimming|
        SkImage describes a two dimensional array of pixels to draw. The pixels may be
        decoded in a raster bitmap, encoded in a SkPicture or compressed data stream,
        or located in GPU memory as a GPU texture.

        SkImage cannot be modified after it is created. SkImage may allocate additional
        storage as needed; for instance, an encoded SkImage may decode when drawn.

        SkImage width and height are greater than zero. Creating an SkImage with zero width
        or height returns SkImage equal to nullptr.

        SkImage may be created from SkBitmap, SkPixmap, SkSurface, SkPicture, encoded streams,
        GPU texture, YUV_ColorSpace data, or hardware buffer. Encoded streams supported
        include BMP, GIF, HEIF, ICO, JPEG, PNG, WBMP, WebP. Supported encoding details
        vary with platform.

        See SkImages namespace for the static factory methods to make SkImages.

        Clients should *not* subclass SkImage as there is a lot of internal machinery that is
        not publicly accessible.
    |]
 )

$( qGenerateSKObject
    "SKMaskFilter"
    ''Sk_maskfilter
    [''SKFlattenable] -- class SK_API SkMaskFilter : public SkFlattenable {
    [trimming|
        SkMaskFilter is the base class for object that perform transformations on
        the mask before drawing it. An example subclass is Blur.
    |]
 )

$( qGenerateSKObject
    "SKPaint"
    ''Sk_paint
    [] -- class SK_API SkPaint {
    [trimming|
        SkPaint controls options applied when drawing. SkPaint collects all
        options outside of the SkCanvas clip and SkCanvas matrix.

        Various options apply to strokes and fills, and images.

        SkPaint collects effects and filters that describe single-pass and multiple-pass
        algorithms that alter the drawing geometry, color, and transparency. For instance,
        SkPaint does not directly implement dashing or blur, but contains the objects that do so.
    |]
 )

$( qGenerateSKObject
    "SKFont"
    ''Sk_font
    [] -- class SK_API SkFont {
    [trimming|
        SkFont controls options applied when drawing and measuring text.
    |]
 )
$( qGenerateSKObject
    "SKPath"
    ''Sk_path
    [] -- class SK_API SkPath {
    [trimming|
        SkPath contain geometry. SkPath may be empty, or contain one or more verbs that
        outline a figure. SkPath always starts with a move verb to a Cartesian coordinate,
        and may be followed by additional verbs that add lines or curves.
        Adding a close verb makes the geometry into a continuous loop, a closed contour.
        SkPath may contain any number of contours, each beginning with a move verb.

        SkPath contours may contain only a move verb, or may also contain lines,
        quadratic beziers, conics, and cubic beziers. SkPath contours may be open or
        closed.

        When used to draw a filled area, SkPath describes whether the fill is inside or
        outside the geometry. SkPath also describes the winding rule used to fill
        overlapping contours.

        Internally, SkPath lazily computes metrics likes bounds and convexity. Call
        SkPath::updateBoundsCache to make SkPath thread safe.
    |]
 )

$( qGenerateSKObject
    "SKPicture"
    ''Sk_picture
    [''SKRefCnt] -- class SK_API SkPicture : public SkRefCnt {
    [trimming|
        SkPicture records drawing commands made to SkCanvas. The command stream may be
        played in whole or in part at a later time.

        SkPicture is an abstract class. SkPicture may be generated by SkPictureRecorder
        or SkDrawable, or from SkPicture previously saved to SkData or SkStream.

        SkPicture may contain any SkCanvas drawing command, as well as one or more
        SkCanvas matrix or SkCanvas clip. SkPicture has a cull SkRect, which is used as
        a bounding box hint. To limit SkPicture bounds, use SkCanvas clip when
        recording or drawing SkPicture.
    |]
 )

$( qGenerateSKObject
    "SKPictureRecorder"
    ''Sk_picture_recorder
    [] -- class SK_API SkPictureRecorder {
    -- NOTE: Comment is taken from https://learn.microsoft.com/en-us/dotnet/api/skiasharp.skpicturerecorder?view=skiasharp-2.88
    [trimming|
        The picture recorder is used to record drawing operations made to a SKCanvas and stored in a SKPicture.
    |]
 )

$( qGenerateSKObject
    "SKBBHFactory"
    ''Sk_bbh_factory
    [] -- class SK_API SkBBHFactory {
    ""
 )

$( qGenerateSKObject
    "SKRTreeFactory"
    ''Sk_rtree_factory
    [''SKBBHFactory] -- class SK_API SkRTreeFactory : public SkBBHFactory {
    ""
 )

$( qGenerateSKObject
    "SKShader"
    ''Sk_shader
    [''SKFlattenable] -- class SK_API SkShader : public SkFlattenable {
    [trimming|
        Shaders specify the source color(s) for what is being drawn. If a paint
        has no shader, then the paint's color is used. If the paint has a
        shader, then the shader's color(s) are use instead, but they are
        modulated by the paint's alpha. This makes it easy to create a shader
        once (e.g. bitmap tiling or gradient) and then change its transparency
        w/o having to modify the original shader... only the paint's alpha needs
        to be modified.
    |]
 )

$( qGenerateSKObject
    "SKSurface"
    ''Sk_surface
    []
    [trimming|
        SkSurface is responsible for managing the pixels that a canvas draws into. The pixels can be
        allocated either in CPU memory (a raster surface) or on the GPU (a GrRenderTarget surface).
        SkSurface takes care of allocating a SkCanvas that will draw into the surface. Call
        surface->getCanvas() to use that canvas (but don't delete it, it is owned by the surface).
        SkSurface always has non-zero dimensions. If there is a request for a new surface, and either
        of the requested dimensions are zero, then nullptr will be returned.

        Clients should *not* subclass SkSurface as there is a lot of internal machinery that is
        not publicly accessible.
    |]
 )

$( qGenerateSKObject
    "SKRegion"
    ''Sk_region
    [] -- class SK_API SkRegion {
    [trimming|
        SkRegion describes the set of pixels used to clip SkCanvas. SkRegion is compact,
        efficiently storing a single integer rectangle, or a run length encoded array
        of rectangles. SkRegion may reduce the current SkCanvas clip, or may be drawn as
        one or more integer rectangles. SkRegion iterator returns the scan lines or
        rectangles contained by it, optionally intersecting a bounding rectangle.
    |]
 )

$( qGenerateSKObject
    "SKRegionIterator"
    ''Sk_region_iterator
    [] --     class SK_API Iterator {
    [trimming|
        An inner class of 'SKRegion'.

        Returns sequence of rectangles, sorted along y-axis, then x-axis, that make
        up SkRegion.
    |]
 )

$( qGenerateSKObject
    "SKRegionCliperator"
    ''Sk_region_cliperator
    [] --     class SK_API Cliperator
    [trimming|
        An inner class of 'SKRegion'.

        Returns the sequence of rectangles, sorted along y-axis, then x-axis, that make
        up SkRegion intersected with the specified clip rectangle.
    |]
 )

$( qGenerateSKObject
    "SKRegionSpanerator"
    ''Sk_region_spanerator
    [] --     class SK_API Spanerator
    [trimming|
        An inner class of 'SKRegion'.

        Returns the line segment ends within SkRegion that intersect a horizontal line.
    |]
 )

$( qGenerateSKObject
    "SKString"
    ''Sk_string
    [] -- class SK_API SkString {
    [trimming|
        Light weight class for managing strings. Uses reference
        counting to make string assignments and copies very fast
        with no extra RAM cost. Assumes UTF8 encoding.
    |]
 )

$( qGenerateSKObject
    "SKBitmap"
    ''Sk_bitmap
    [] -- class SK_API SkBitmap {
    [trimming|
        SkBitmap describes a two-dimensional raster pixel array. SkBitmap is built on
        SkImageInfo, containing integer width and height, SkColorType and SkAlphaType
        describing the pixel format, and SkColorSpace describing the range of colors.
        SkBitmap points to SkPixelRef, which describes the physical array of pixels.
        SkImageInfo bounds may be located anywhere fully inside SkPixelRef bounds.

        SkBitmap can be drawn using SkCanvas. SkBitmap can be a drawing destination for SkCanvas
        draw member functions. SkBitmap flexibility as a pixel container limits some
        optimizations available to the target platform.

        If pixel array is primarily read-only, use SkImage for better performance.
        If pixel array is primarily written to, use SkSurface for better performance.

        Declaring SkBitmap const prevents altering SkImageInfo: the SkBitmap height, width,
        and so on cannot change. It does not affect SkPixelRef: a caller may write its
        pixels. Declaring SkBitmap const affects SkBitmap configuration, not its contents.

        SkBitmap is not thread safe. Each thread must have its own copy of SkBitmap fields,
        although threads may share the underlying pixel array.
    |]
 )

$( qGenerateSKObject
    "SKPixmap"
    ''Sk_pixmap
    [] -- class SK_API SkPixmap {
    [trimming|
        SkPixmap provides a utility to pair SkImageInfo with pixels and row bytes.
        SkPixmap is a low level class which provides convenience functions to access
        raster destinations. SkCanvas can not draw SkPixmap, nor does SkPixmap provide
        a direct drawing destination.

        Use SkBitmap to draw pixels referenced by SkPixmap; use SkSurface to draw into
        pixels referenced by SkPixmap.

        SkPixmap does not try to manage the lifetime of the pixel memory. Use SkPixelRef
        to manage pixel memory; SkPixelRef is safe across threads.
    |]
 )

$( qGenerateSKObject
    "SKColorFilter"
    ''Sk_colorfilter
    [''SKFlattenable] -- class SK_API SkColorFilter : public SkFlattenable {
    [trimming|
        ColorFilters are optional objects in the drawing pipeline. When present in
        a paint, they are called with the "src" colors, and return new colors, which
        are then passed onto the next stage (either ImageFilter or Xfermode).

        All subclasses are required to be reentrant-safe : it must be legal to share
        the same instance between several threads.
    |]
 )

$( qGenerateSKObject
    "SKImageFilter"
    ''Sk_imagefilter
    [''SKFlattenable] -- class SK_API SkImageFilter : public SkFlattenable {
    [trimming|
        Base class for image filters. If one is installed in the paint, then all drawing occurs as
        usual, but it is as if the drawing happened into an offscreen (before the xfermode is applied).
        This offscreen bitmap will then be handed to the imagefilter, who in turn creates a new bitmap
        which is what will finally be drawn to the device (using the original xfermode).
        
        The local space of image filters matches the local space of the drawn geometry. For instance if
        there is rotation on the canvas, the blur will be computed along those rotated axes and not in
        the device space. In order to achieve this result, the actual drawing of the geometry may happen
        in an unrotated coordinate system so that the filtered image can be computed more easily, and
        then it will be post transformed to match what would have been produced if the geometry were
        drawn with the total canvas matrix to begin with.
    |]
 )

$( qGenerateSKObject
    "SKBlender"
    ''Sk_blender
    [''SKFlattenable] -- class SK_API SkBlender : public SkFlattenable {
    [trimming|
        SkBlender represents a custom blend function in the Skia pipeline. When an SkBlender is
        present in a paint, the SkBlendMode is ignored. A blender combines a source color (the
        result of our paint) and destination color (from the canvas) into a final color.
    |]
 )
$( qGenerateSKObject
    "SKTypeface"
    ''Sk_typeface
    [''SKWeakRefCnt] -- class SK_API SkTypeface : public SkWeakRefCnt {
    [trimming|
        The SkTypeface class specifies the typeface and intrinsic style of a font.
        This is used in the paint, along with optionally algorithmic settings like
        textSize, textSkewX, textScaleX, kFakeBoldText_Mask, to specify
        how text appears when drawn (and measured).

        Typeface objects are immutable, and so they can be shared between threads.
    |]
 )
$( qGenerateSKObject
    "SKFontManager"
    ''Sk_fontmgr
    [''SKRefCnt] -- class SK_API SkFontMgr : public SkRefCnt {
    ""
 )

-- This is replaced by 'data FontStyle':
-- \$(qGenerateSKObject "SKFontStyle" ''Sk_fontstyle)

$( qGenerateSKObject
    "SKFontStyleSet"
    ''Sk_fontstyleset
    [''SKRefCnt] -- class SK_API SkFontStyleSet : public SkRefCnt {
    ""
 )

$( qGenerateSKObject
    "SKCodec"
    ''Sk_codec
    -- NOTE: We ignore SkNoncopyable
    [] -- class SK_API SkCodec : SkNoncopyable {
    [trimming|
        Abstraction layer directly on top of an image codec.
    |]
 )

$( qGenerateSKObject
    "SKColorSpace"
    ''Sk_colorspace
    [''SKNVRefCnt] -- class SK_API SkColorSpace : public SkNVRefCnt<SkColorSpace> {
    ""
 )

$( qGenerateSKObject
    "SKWStream"
    ''Sk_wstream
    [] -- class SK_API SkWStream {
    ""
 )

$( qGenerateSKObject
    "SKFileWStream"
    ''Sk_wstream_filestream
    [''SKWStream] -- class SK_API SkFILEWStream : public SkWStream {
    ""
 )

$( qGenerateSKObject
    "SKStream"
    ''Sk_stream
    [] -- class SK_API SkStream {
    [trimming|
        SkStream -- abstraction for a source of bytes. Subclasses can be backed by
        memory, or a file, or something else.

        NOTE:

        Classic "streams" APIs are sort of async, in that on a request for N
        bytes, they may return fewer than N bytes on a given call, in which case
        the caller can "try again" to get more bytes, eventually (modulo an error)
        receiving their total N bytes.

        Skia streams behave differently. They are effectively synchronous, and will
        always return all N bytes of the request if possible. If they return fewer
        (the read() call returns the number of bytes read) then that means there is
        no more data (at EOF or hit an error). The caller should *not* call again
        in hopes of fulfilling more of the request.
    |]
 )

$( qGenerateSKObject
    "SKFileStream"
    ''Sk_stream_filestream
    [''SKWStream] -- class SK_API SkFILEWStream : public SkWStream {
    ""
 )

$( qGenerateSKObject
    "SKStreamRewindable"
    ''Sk_stream_streamrewindable
    [''SKStream] -- class SK_API SkStreamRewindable : public SkStream {
    [trimming|
        SkStreamRewindable is a SkStream for which rewind and duplicate are required.
    |]
 )

$( qGenerateFakeSKObject
    "SKStreamSeekable"
    [''SKStreamRewindable]
    [trimming|
        SkStreamSeekable is a SkStreamRewindable for which position, seek, move, and fork are required.
    |]
 )

$( qGenerateSKObject
    "SKStreamAsset"
    ''Sk_stream_asset
    [''SKStreamSeekable] -- class SK_API SkStreamAsset : public SkStreamSeekable {
    [trimming|
        SkStreamAsset is a SkStreamSeekable for which getLength is required.
    |]
 )

$( qGenerateFakeSKObject
    "SKStreamMemory"
    [''SKStreamAsset]
    [trimming|
        SkStreamMemory is a 'SKStreamAsset' for which getMemoryBase is required.
    |]
 )

$( qGenerateSKObject
    "SKMemoryStream"
    ''Sk_stream_memorystream
    [''SKStreamMemory]
    [trimming|
        'SKMemoryStream' is a basic implementation of 'SKStreamMemory'.

        It is a light-weight container holding a pointer + an offset.
    |]
 )

$( qGenerateSKObject
    "SKDynamicMemoryWStream"
    ''Sk_wstream_dynamicmemorystream
    [''SKWStream] -- class SK_API SkDynamicMemoryWStream : public SkWStream {
    ""
 )

$( qGenerateSKObject
    "SKDocument"
    ''Sk_document
    [''SKRefCnt] -- class SK_API SkDocument : public SkRefCnt {
    [trimming|
        High-level API for creating a document-based canvas. To use..

        @
        1. Create a document, specifying a stream to store the output.
        2. For each "page" of content:
            a. canvas = doc->beginPage(...)
            b. draw_my_content(canvas);
            c. doc->endPage();
        3. Close the document with doc->close().
        @
    |]
 )

$( qGenerateSKObject
    "SKPathIterator"
    ''Sk_path_iterator
    [] --     class SK_API Iter {
    [trimming|
        Iterates through verb array, and associated SkPoint array and conic weight.
        Provides options to treat open contours as closed, and to ignore
        degenerate data.
    |]
 )

$( qGenerateSKObject
    "SKPathRawIterator"
    ''Sk_path_rawiterator
    [] --     class SK_API RawIter {
    [trimming|
        Use 'SKPathIterator' instead. This class will soon be removed and RangeIter will be made private.
    |]
 )

$( qGenerateSKObject
    "SKPathEffect"
    ''Sk_path_effect
    [''SKFlattenable] -- class SK_API SkPathEffect : public SkFlattenable {
    [trimming|
        SkPathEffect is the base class for objects in the SkPaint that affect
        the geometry of a drawing primitive before it is transformed by the
        canvas' matrix and drawn.

        Dashing is implemented as a subclass of SkPathEffect.
    |]
 )

-- This type is never used in Mono Skia.

-- $(qGenerateSKObject "SKPixelRefFactory" ''Sk_pixelref_factory "")

$( qGenerateSKObject
    "GRBackendRenderTarget"
    ''Gr_backendrendertarget
    [] -- class SK_API GrBackendRenderTarget {
    ""
 )

$( qGenerateSKObject
    "GRBackendTexture"
    ''Gr_backendtexture
    [] -- class SK_API GrBackendTexture {
    ""
 )

$( qGenerateSKObject
    "GRRecordingContext"
    ''Gr_recording_context
    -- NOTE: GRRecordingContext : public GrImageContext : public GrContext_Base : public SkRefCnt.
    -- We skip the intermediaries for convenience.
    [''SKRefCnt] -- class GrRecordingContext : public GrImageContext { ...
    ""
 )

$( qGenerateSKObject
    "GRDirectContext"
    ''Gr_direct_context
    [''GRRecordingContext] -- class SK_API GrDirectContext : public GrRecordingContext {
    ""
 )

$( qGenerateSKObject
    "GRGlInterface"
    ''Gr_glinterface
    [''SKRefCnt] -- struct SK_API GrGLInterface : public SkRefCnt {
    [trimming|
        GrContext uses the following interface to make all calls into OpenGL. When a
        GrContext is created it is given a GrGLInterface. The interface's function
        pointers must be valid for the OpenGL context associated with the GrContext.
        On some platforms, such as Windows, function pointers for OpenGL extensions
        may vary between OpenGL contexts. So the caller must be careful to use a
        GrGLInterface initialized for the correct context. All functions that should
        be available based on the OpenGL's version and extension string must be
        non-NULL or GrContext creation will fail. This can be tested with the
        validate() method when the OpenGL context has been made current.
    |]
 )

$( qGenerateSKObject
    "VkInstance"
    ''Vk_instance
    []
    [trimming|
        An opaque structure of the type <https://registry.khronos.org/vulkan/specs/latest/man/html/VkInstance.html>.
    |]
 )

$( qGenerateSKObject
    "GRVkInterface"
    ''Gr_vkinterface
    []
    ""
 )

$(qGenerateSKObject "VkPhysicalDevice" ''Vk_physical_device [] "")
$(qGenerateSKObject "VkPhysicalDeviceFeatures" ''Vk_physical_device_features [] "")
$(qGenerateSKObject "VkPhysicalDeviceFeatures2" ''Vk_physical_device_features_2 [] "")
$(qGenerateSKObject "VkDevice" ''Vk_device [] "")
$(qGenerateSKObject "VkQueue" ''Vk_queue [] "")
$(qGenerateSKObject "GRVkExtensions" ''Gr_vk_extensions [] "")
$(qGenerateSKObject "GRVkMemoryAllocator" ''Gr_vk_memory_allocator [] "")

$( qGenerateSKObject
    "SKPathOpBuilder"
    ''Sk_opbuilder
    [] -- class SK_API SkOpBuilder {
    [trimming|
        Perform a series of path operations, optimized for unioning many paths together.
    |]
 )

$( qGenerateSKObject
    "SKPathMeasure"
    ''Sk_pathmeasure
    [] -- class SK_API SkPathMeasure {
    ""
 )

$( qGenerateSKObject
    "SKSVGCanvas"
    ''Sk_svgcanvas
    [] -- class SK_API SkSVGCanvas {
    [trimming|
        This canvas generates SVG commands from its draw calls, and send
        them to its underlying stream.
    |]
 )

$( qGenerateSKObject
    "SKVertices"
    ''Sk_vertices
    [''SKNVRefCnt]
    [trimming|
        An immutable set of vertex data that can be used with SkCanvas::drawVertices.
    |]
 )

$( qGenerateSKObject
    "SKColorSpaceICCProfile"
    ''Sk_colorspace_icc_profile
    [] -- typedef struct skcms_ICCProfile {
    ""
 )

$( qGenerateSKObject
    "SKRoundRect"
    ''Sk_rrect
    [] -- class SK_API SkRRect {
    [trimming|
        SkRRect describes a rounded rectangle with a bounds and a pair of radii for each corner.
        The bounds and radii can be set so that SkRRect describes: a rectangle with sharp corners;
        a circle; an oval; or a rectangle with one or more rounded corners.

        SkRRect allows implementing CSS properties that describe rounded corners.
        SkRRect may have up to eight different radii, one for each axis on each of its four
        corners.

        SkRRect may modify the provided parameters when initializing bounds and radii.
        If either axis radii is zero or less: radii are stored as zero; corner is square.
        If corner curves overlap, radii are proportionally reduced to fit within bounds.
    |]
 )

$( qGenerateSKObject
    "SKTextBlob"
    ''Sk_textblob
    [''SKNVRefCnt] -- class SK_API SkTextBlob final : public SkNVRefCnt<SkTextBlob> {
    [trimming|
        SkTextBlob combines multiple text runs into an immutable container. Each text
        run consists of glyphs, SkPaint, and position. Only parts of SkPaint related to
        fonts and text rendering are used by run.
    |]
 )

$( qGenerateSKObject
    "SKTextBlobBuilder"
    ''Sk_textblob_builder
    [] -- class SK_API SkTextBlobBuilder {
    [trimming|
        Helper class for constructing SkTextBlob.
    |]
 )

$( qGenerateSKObject
    "SKTraceMemoryDump"
    ''Sk_tracememorydump
    [] -- class SK_API SkTraceMemoryDump {
    [trimming|
        Interface for memory tracing.
        This interface is meant to be passed as argument to the memory dump methods of Skia objects.
        The implementation of this interface is provided by the embedder.
    |]
 )

$( qGenerateSKObject
    "SKRuntimeEffect"
    ''Sk_runtimeeffect
    [''SKRefCnt] -- class SK_API SkRuntimeEffect : public SkRefCnt {
    [trimming|
        SkRuntimeEffect supports creating custom SkShader and SkColorFilter objects using Skia's SkSL
        shading language.
        
        Google Skia's NOTE: This API is experimental and subject to change.
    |]
 )

$( qGenerateSKObject
    "SkottieAnimation"
    ''Skottie_animation
    [''SKNVRefCnt] -- class SK_API Animation : public SkNVRefCnt<Animation> {
    ""
 )

$( qGenerateSKObject
    "SkottieAnimationBuilder"
    ''Skottie_animation_builder
    [] --     class SK_API Builder final {
    ""
 )

-- See modules/skottie/include/Skottie.h: @using ResourceProvider = skresources::ResourceProvider;@
-- skresources::ResourceProvider is already defined as 'SKResourcesResourceProvider'
--

-- $(qGenerateSKObject "SkottieResourceProvider" ''Skottie_resource_provider "")

$( qGenerateSKObject
    "SkottiePropertyObserver"
    ''Skottie_property_observer
    [''SKRefCnt] -- class SK_API PropertyObserver : public SkRefCnt {
    [trimming|
        A PropertyObserver can be used to track and manipulate certain properties of "interesting"
        Lottie nodes.
        
        When registered with an animation builder, PropertyObserver receives notifications for
        various properties of layer and shape nodes.  The |node_name| argument corresponds to the
        name ("nm") node property.
    |]
 )

$( qGenerateSKObject
    "SkottieLogger"
    ''Skottie_logger
    [''SKRefCnt] -- class SK_API Logger : public SkRefCnt {
    [trimming|
        A Logger subclass can be used to receive Animation::Builder parsing errors and warnings.
    |]
 )

$( qGenerateSKObject
    "SkottieMarkerObserver"
    ''Skottie_marker_observer
    [''SKRefCnt] -- class SK_API MarkerObserver : public SkRefCnt {
    [trimming|
        Interface for receiving AE composition markers at Animation build time.
    |]
 )

$( qGenerateSKObject
    "SKSGInvalidationController"
    ''Sksg_invalidation_controller
    [] -- class InvalidationController {
    [trimming|
        Google Skia: "Receiver for invalidation events. Tracks dirty regions for repaint."

        This structure is a light-weight container holding a vector of rectangles.
    |]
 )

$( qGenerateSKObject
    "SKResourcesImageAsset"
    ''Skresources_image_asset
    [''SKRefCnt] -- class SK_API ImageAsset : public SkRefCnt {
    [trimming|
        Image asset proxy interface.
    |]
 )

$( qGenerateSKObject
    "SKResourcesMultiFrameImageAsset"
    ''Skresources_multi_frame_image_asset
    [''SKResourcesImageAsset] -- class MultiFrameImageAsset final : public ImageAsset {
    ""
 )

$( qGenerateSKObject
    "SKResourcesExternalTrackAsset"
    ''Skresources_external_track_asset
    [''SKRefCnt] -- class ExternalTrackAsset : public SkRefCnt {
    [trimming|
        External track (e.g. audio playback) interface.

        Used to wrap data payload and playback controllers.
    |]
 )

$( qGenerateSKObject
    "SKResourcesResourceProvider"
    ''Skresources_resource_provider
    [''SKRefCnt] -- class SK_API ResourceProvider : public SkRefCnt {
    [trimming|
        ResourceProvider is an interface that lets rich-content modules defer loading of external
        resources (images, fonts, etc.) to embedding clients.
    |]
 )

$(qGenerateSKObject "D3DDXGIAdapter" ''D3d_dxgi_adapter [] "")

$(qGenerateSKObject "D3DD12Device" ''D3d_d12_device [] "")

$(qGenerateSKObject "D3DD12CommandQueue" ''D3d_d12_command_queue [] "")

$(qGenerateSKObject "GRD3DMemoryAllocator" ''Gr_d3d_memory_allocator [] "")

$(qGenerateSKObject "D3DD12Resource" ''D3d_d12_resource [] "")

$(qGenerateSKObject "D3DAlloc" ''D3d_alloc [] "")

-- ### Xamarin's structs

$( qGenerateSKObject
    "SKManagedStream"
    ''Sk_stream_managedstream
    [''SKStreamAsset] -- class SkManagedStream : public SkStreamAsset {
    ""
 )

$( qGenerateSKObject
    "SKManagedWStream"
    ''Sk_wstream_managedstream
    [''SKWStream] -- class SkManagedWStream : public SkWStream {
    ""
 )

$( qGenerateSKObject
    "SKManagedDrawable"
    ''Sk_manageddrawable
    [''SKDrawable] -- class SkManagedDrawable : public SkDrawable {
    ""
 )

$( qGenerateSKObject
    "SKManagedTraceMemoryDump"
    ''Sk_managedtracememorydump
    [''SKTraceMemoryDump] -- class SK_API SkManagedTraceMemoryDump : public SkTraceMemoryDump {
    ""
 )

-- ###### Some fake and unusable Skia object types created for Haddock documentation purposes.

{- | NOTE: This is an unusable Skia object type created for Haddock
documentation purposes.

This class is the smart container for pixel memory, and is used with 'SKBitmap'.
This class can be shared/accessed between multiple threads.
-}
type SKPixelRef = ()
