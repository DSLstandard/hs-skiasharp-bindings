-- NOTE: We must explicitly export the functions. Otherwise, internal functions
-- generated by 'inline-c' will be exposed and could be found on the Haddock
-- documentation, which is not good.
module Skia.Bindings.Internal.Manual (
    gr_direct_context_make_direct3d,
    gr_direct_context_make_direct3d_with_options,
    gr_direct_context_make_vulkan,
    gr_direct_context_make_vulkan_with_options,
    sk_canvas_clear_color4f,
    sk_canvas_draw_color4f,
    sk_manageddrawable_set_procs,
    sk_managedtracememorydump_set_procs,
    sk_managedwstream_set_procs,
    sk_managedstream_set_procs,
    pattern DYNAMIC_MSAA_SK_SURFACE_PROPS_FLAGS,
    pattern ALWAYS_DITHER_SK_SURFACE_PROPS_FLAGS,
)
where

import Language.C.Inline qualified as C

import Foreign
import Skia.Bindings.Internal.AutoGenerated

C.include "<c/gr_context.h>"
C.include "<c/sk_bitmap.h>"
C.include "<c/sk_blender.h>"
C.include "<c/sk_canvas.h>"
C.include "<c/sk_codec.h>"
C.include "<c/sk_colorfilter.h>"
C.include "<c/sk_colorspace.h>"
C.include "<c/sk_data.h>"
C.include "<c/sk_document.h>"
C.include "<c/sk_drawable.h>"
C.include "<c/sk_font.h>"
C.include "<c/sk_general.h>"
C.include "<c/sk_graphics.h>"
C.include "<c/sk_image.h>"
C.include "<c/sk_imagefilter.h>"
C.include "<c/sk_linker.h>"
C.include "<c/sk_maskfilter.h>"
C.include "<c/sk_matrix.h>"
C.include "<c/sk_paint.h>"
C.include "<c/sk_path.h>"
C.include "<c/sk_patheffect.h>"
C.include "<c/sk_picture.h>"
C.include "<c/sk_pixmap.h>"
C.include "<c/sk_region.h>"
C.include "<c/sk_rrect.h>"
C.include "<c/sk_runtimeeffect.h>"
C.include "<c/sk_shader.h>"
C.include "<c/sk_stream.h>"
C.include "<c/sk_string.h>"
C.include "<c/sk_surface.h>"
C.include "<c/sk_svg.h>"
C.include "<c/sk_textblob.h>"
C.include "<c/sk_typeface.h>"
C.include "<c/sk_types.h>"
C.include "<c/sk_vertices.h>"
C.include "<c/skottie_animation.h>"
C.include "<c/skresources_resource_provider.h>"
C.include "<c/sksg_invalidation_controller.h>"
C.include "<xamarin/sk_manageddrawable.h>"
C.include "<xamarin/sk_managedtracememorydump.h>"
C.include "<xamarin/sk_managedstream.h>"
C.include "<xamarin/sk_compatpaint.h>"
C.include "<xamarin/sk_xamarin.h>"

-- TODO: Learn how to use inline-c properly for passing C structure values.

-- | `gr_direct_context_make_direct3d`
gr_direct_context_make_direct3d :: Gr_d3d_backendcontext -> IO (Ptr Gr_direct_context)
gr_direct_context_make_direct3d ctx = do
    let adapter = castPtr ctx.fAdapter
    let device = castPtr ctx.fDevice
    let queue = castPtr ctx.fQueue
    let memoryAllocator = castPtr ctx.fMemoryAllocator
    let protectedContext = ctx.fProtectedContext

    ptr <-
        [C.block|void* {
            gr_d3d_backendcontext_t in;
            in.fAdapter = $(void* adapter);
            in.fDevice = $(void* device);
            in.fQueue = $(void* queue);
            in.fMemoryAllocator = $(void* memoryAllocator);
            in.fProtectedContext = $(bool protectedContext);

            return gr_direct_context_make_direct3d(in);
        }|]
    pure (castPtr ptr)

-- | `gr_direct_context_make_direct3d_with_options`
gr_direct_context_make_direct3d_with_options :: Gr_d3d_backendcontext -> Ptr Gr_context_options -> IO (Ptr Gr_direct_context)
gr_direct_context_make_direct3d_with_options ctx inOptions = do
    let adapter = castPtr ctx.fAdapter
    let device = castPtr ctx.fDevice
    let queue = castPtr ctx.fQueue
    let memoryAllocator = castPtr ctx.fMemoryAllocator
    let protectedContext = ctx.fProtectedContext

    let options = castPtr inOptions

    ptr <-
        [C.block|void* {
            gr_d3d_backendcontext_t in;
            in.fAdapter = $(void* adapter);
            in.fDevice = $(void* device);
            in.fQueue = $(void* queue);
            in.fMemoryAllocator = $(void* memoryAllocator);
            in.fProtectedContext = $(bool protectedContext);

            return gr_direct_context_make_direct3d_with_options(in, $(void* options));
        }|]
    pure (castPtr ptr)

-- | `gr_direct_context_make_vulkan`
gr_direct_context_make_vulkan :: Gr_vk_backendcontext -> IO (Ptr Gr_direct_context)
gr_direct_context_make_vulkan ctx = do
    let instancePtr = castPtr ctx.fInstance
    let physicalDevice = castPtr ctx.fPhysicalDevice
    let device = castPtr ctx.fDevice
    let queue = castPtr ctx.fQueue
    let graphicsQueueIndex = ctx.fGraphicsQueueIndex
    let minAPIVersion = ctx.fMinAPIVersion
    let instanceVersion = ctx.fInstanceVersion
    let maxAPIVersion = ctx.fMaxAPIVersion
    let extensions = ctx.fExtensions
    let vkExtensions = castPtr ctx.fVkExtensions
    let features = ctx.fFeatures
    let deviceFeatures = castPtr ctx.fDeviceFeatures
    let deviceFeatures2 = castPtr ctx.fDeviceFeatures2
    let memoryAllocator = castPtr ctx.fMemoryAllocator
    let getProc :: Ptr () = castFunPtrToPtr ctx.fGetProc
    let getProcUserData = castPtr ctx.fGetProcUserData
    let ownsInstanceAndDevice = ctx.fOwnsInstanceAndDevice
    let protectedContext = ctx.fProtectedContext

    ptr <-
        [C.block|void* {
            gr_vk_backendcontext_t in;
            in.fInstance = $(void* instancePtr);
            in.fPhysicalDevice = $(void* physicalDevice);
            in.fDevice = $(void* device);
            in.fQueue = $(void* queue);
            in.fGraphicsQueueIndex = $(uint32_t graphicsQueueIndex);
            in.fMinAPIVersion = $(uint32_t minAPIVersion);
            in.fInstanceVersion = $(uint32_t instanceVersion);
            in.fMaxAPIVersion = $(uint32_t maxAPIVersion);
            in.fExtensions = $(uint32_t extensions);
            in.fVkExtensions = $(void* vkExtensions);
            in.fFeatures = $(uint32_t features);
            in.fDeviceFeatures = $(void* deviceFeatures);
            in.fDeviceFeatures2 = $(void* deviceFeatures2);
            in.fMemoryAllocator = $(void* memoryAllocator);
            in.fGetProc = $(void* getProc);
            in.fGetProcUserData = $(void* getProcUserData);
            in.fOwnsInstanceAndDevice = $(bool ownsInstanceAndDevice);
            in.fProtectedContext = $(bool protectedContext);

            return gr_direct_context_make_vulkan(in);
        }|]
    pure (castPtr ptr)

-- | `gr_direct_context_make_vulkan_with_options`
gr_direct_context_make_vulkan_with_options :: Gr_vk_backendcontext -> Ptr Gr_context_options -> IO (Ptr Gr_direct_context)
gr_direct_context_make_vulkan_with_options ctx inOptions = do
    let instancePtr = castPtr ctx.fInstance
    let physicalDevice = castPtr ctx.fPhysicalDevice
    let device = castPtr ctx.fDevice
    let queue = castPtr ctx.fQueue
    let graphicsQueueIndex = ctx.fGraphicsQueueIndex
    let minAPIVersion = ctx.fMinAPIVersion
    let instanceVersion = ctx.fInstanceVersion
    let maxAPIVersion = ctx.fMaxAPIVersion
    let extensions = ctx.fExtensions
    let vkExtensions = castPtr ctx.fVkExtensions
    let features = ctx.fFeatures
    let deviceFeatures = castPtr ctx.fDeviceFeatures
    let deviceFeatures2 = castPtr ctx.fDeviceFeatures2
    let memoryAllocator = castPtr ctx.fMemoryAllocator
    let getProc :: Ptr () = castFunPtrToPtr ctx.fGetProc
    let getProcUserData = castPtr ctx.fGetProcUserData
    let ownsInstanceAndDevice = ctx.fOwnsInstanceAndDevice
    let protectedContext = ctx.fProtectedContext

    let options = castPtr inOptions

    ptr <-
        [C.block|void* {
            gr_vk_backendcontext_t in;
            in.fInstance = $(void* instancePtr);
            in.fPhysicalDevice = $(void* physicalDevice);
            in.fDevice = $(void* device);
            in.fQueue = $(void* queue);
            in.fGraphicsQueueIndex = $(uint32_t graphicsQueueIndex);
            in.fMinAPIVersion = $(uint32_t minAPIVersion);
            in.fInstanceVersion = $(uint32_t instanceVersion);
            in.fMaxAPIVersion = $(uint32_t maxAPIVersion);
            in.fExtensions = $(uint32_t extensions);
            in.fVkExtensions = $(void* vkExtensions);
            in.fFeatures = $(uint32_t features);
            in.fDeviceFeatures = $(void* deviceFeatures);
            in.fDeviceFeatures2 = $(void* deviceFeatures2);
            in.fMemoryAllocator = $(void* memoryAllocator);
            in.fGetProc = $(void* getProc);
            in.fGetProcUserData = $(void* getProcUserData);
            in.fOwnsInstanceAndDevice = $(bool ownsInstanceAndDevice);
            in.fProtectedContext = $(bool protectedContext);

            return gr_direct_context_make_vulkan_with_options(in, $(void* options));
        }|]
    pure (castPtr ptr)

-- | `sk_canvas_clear_color4f`
sk_canvas_clear_color4f :: Ptr Sk_canvas -> Sk_color4f -> IO ()
sk_canvas_clear_color4f inCanvas Sk_color4f{fR, fG, fB, fA} = do
    let canvas = castPtr inCanvas
    [C.block|void {
        sk_color4f_t color = {$(float fR), $(float fG), $(float fB), $(float fA)};
        sk_canvas_clear_color4f($(void* canvas), color);
    }|]

-- | `sk_canvas_draw_color4f`
sk_canvas_draw_color4f :: Ptr Sk_canvas -> Sk_color4f -> Sk_blendmode -> IO ()
sk_canvas_draw_color4f inCanvas Sk_color4f{fR, fG, fB, fA} (Sk_blendmode blendMode) = do
    let canvas = castPtr inCanvas
    [C.block|void {
        sk_color4f_t color = {$(float fR), $(float fG), $(float fB), $(float fA)};
        sk_canvas_draw_color4f($(void* canvas), color, $(uint32_t blendMode));
    }|]

-- | `sk_manageddrawable_set_procs`
sk_manageddrawable_set_procs :: Sk_manageddrawable_procs -> IO ()
sk_manageddrawable_set_procs procs = do
    let fDraw = castFunPtrToPtr procs.fDraw
    let fGetBounds = castFunPtrToPtr procs.fGetBounds
    let fApproximateBytesUsed = castFunPtrToPtr procs.fApproximateBytesUsed
    let fMakePictureSnapshot = castFunPtrToPtr procs.fMakePictureSnapshot
    let fDestroy = castFunPtrToPtr procs.fDestroy

    [C.block|void {
        sk_manageddrawable_procs_t procs;
        procs.fDraw = $(void* fDraw);
        procs.fGetBounds = $(void* fGetBounds);
        procs.fApproximateBytesUsed = $(void* fApproximateBytesUsed);
        procs.fMakePictureSnapshot = $(void* fMakePictureSnapshot);
        procs.fDestroy = $(void* fDestroy);
        sk_manageddrawable_set_procs(procs);
    }|]

sk_managedtracememorydump_set_procs :: Sk_managedtracememorydump_procs -> IO ()
sk_managedtracememorydump_set_procs procs = do
    let fDumpNumericValue = castFunPtrToPtr procs.fDumpNumericValue
    let fDumpStringValue = castFunPtrToPtr procs.fDumpStringValue

    [C.block|void {
        sk_managedtracememorydump_procs_t procs;
        procs.fDumpNumericValue = $(void* fDumpNumericValue);
        procs.fDumpStringValue = $(void* fDumpStringValue);
        sk_managedtracememorydump_set_procs(procs);
    }|]

sk_managedwstream_set_procs :: Sk_managedwstream_procs -> IO ()
sk_managedwstream_set_procs procs = do
    let fWrite = castFunPtrToPtr procs.fWrite
    let fFlush = castFunPtrToPtr procs.fFlush
    let fBytesWritten = castFunPtrToPtr procs.fBytesWritten
    let fDestroy = castFunPtrToPtr procs.fDestroy
    [C.block|void {
        sk_managedwstream_procs_t procs;
        procs.fWrite = $(void* fWrite);
        procs.fFlush = $(void* fFlush);
        procs.fBytesWritten = $(void* fBytesWritten);
        procs.fDestroy = $(void* fDestroy);
        sk_managedwstream_set_procs(procs);
    }|]

sk_managedstream_set_procs :: Sk_managedstream_procs -> IO ()
sk_managedstream_set_procs procs = do
    let fRead = castFunPtrToPtr procs.fRead
    let fPeek = castFunPtrToPtr procs.fPeek
    let fIsAtEnd = castFunPtrToPtr procs.fIsAtEnd
    let fHasPosition = castFunPtrToPtr procs.fHasPosition
    let fHasLength = castFunPtrToPtr procs.fHasLength
    let fRewind = castFunPtrToPtr procs.fRewind
    let fGetPosition = castFunPtrToPtr procs.fGetPosition
    let fSeek = castFunPtrToPtr procs.fSeek
    let fMove = castFunPtrToPtr procs.fMove
    let fGetLength = castFunPtrToPtr procs.fGetLength
    let fDuplicate = castFunPtrToPtr procs.fDuplicate
    let fFork = castFunPtrToPtr procs.fFork
    let fDestroy = castFunPtrToPtr procs.fDestroy
    [C.block|void {
        sk_managedstream_procs_t procs;
        procs.fRead = $(void* fRead);
        procs.fPeek = $(void* fPeek);
        procs.fIsAtEnd = $(void* fIsAtEnd);
        procs.fHasPosition = $(void* fHasPosition);
        procs.fHasLength = $(void* fHasLength);
        procs.fRewind = $(void* fRewind);
        procs.fGetPosition = $(void* fGetPosition);
        procs.fSeek = $(void* fSeek);
        procs.fMove = $(void* fMove);
        procs.fGetLength = $(void* fGetLength);
        procs.fDuplicate = $(void* fDuplicate);
        procs.fFork = $(void* fFork);
        procs.fDestroy = $(void* fDestroy);
        sk_managedstream_set_procs(procs);
    }|]

-- NOTE: Unfortunately, Mono Skia does not export all enum values of
-- SkSurfaceProps::Flags. We need to figure out all flag values by inspecting
-- include/core/SkSurfaceProps.h.

pattern DYNAMIC_MSAA_SK_SURFACE_PROPS_FLAGS :: Sk_surfaceprops_flags
pattern DYNAMIC_MSAA_SK_SURFACE_PROPS_FLAGS = 2

pattern ALWAYS_DITHER_SK_SURFACE_PROPS_FLAGS :: Sk_surfaceprops_flags
pattern ALWAYS_DITHER_SK_SURFACE_PROPS_FLAGS = 4
